<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>비올레타 탐지기</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        /* 스크롤바 스타일링 */
        .scroll-container::-webkit-scrollbar {
            width: 8px;
        }
        .scroll-container::-webkit-scrollbar-track {
            background: #1f2937;
        }
        .scroll-container::-webkit-scrollbar-thumb {
            background-color: #4b5563;
            border-radius: 4px;
        }
        .coin-list-item:hover {
            background-color: #374151;
            cursor: pointer;
        }
        /* 호가창 물량 배경을 위한 relative position */
        .orderbook-row td {
            position: relative;
        }
        .orderbook-cell {
            position: relative;
            padding: 0.25rem 0;
        }
        .orderbook-background {
            position: absolute;
            top: 0;
            height: 100%;
            opacity: 0.4;
            z-index: 0;
            transition: width 0.3s ease-in-out;
        }
        .ask-bg {
            left: 0;
        }
        .bid-bg {
            right: 0;
        }
        .tab-button.active {
            border-bottom: 2px solid #6366f1;
            color: #ffffff;
        }
        .chart-tab-button.active {
            background-color: #4b5563;
            color: #ffffff;
        }
        .sparkline-container {
            position: relative;
            height: 30px;
            flex: 1 1 0%;
            margin: 0 4px;
        }
        .sparkline-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen p-6 md:p-12">

    <div class="container mx-auto max-w-[1920px] h-screen flex flex-col">
        <div class="flex flex-col md:flex-row items-center justify-between p-6 mb-6 rounded-xl bg-gray-800 shadow-lg">
            <div class="flex items-center space-x-6 mb-6 md:mb-0">
                <h1 class="text-3xl font-bold text-gray-300">비올레타 탐지기</h1>
                <h1 id="coin-korean-name" class="text-3xl font-bold text-gray-300 hidden">비트코인</h1>
                <h1 id="coin-ticker" class="text-xl font-bold text-indigo-400 hidden">BTC-USDT</h1>
                <span id="current-price" class="text-3xl font-bold text-green-400 hidden">--</span>
            </div>
            <div id="market-stats" class="flex items-center space-x-6 text-base hidden">
                <div>거래대금(24H): <span id="trade-volume" class="font-semibold text-gray-300">--</span> USDT</div>
                <div>24H Change: <span id="execution-strength" class="font-semibold text-gray-300">0.00</span> %</div>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 flex-grow">
            <div class="lg:col-span-1 flex flex-col gap-8">
                <div id="main-chart-container" class="bg-gray-800 p-6 rounded-xl shadow-lg">
                    <div id="tradingview_chart" style="height: 750px; width: 100%;"></div>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8 flex-grow">
                    <div id="orderbook-panel" class="bg-gray-800 p-6 rounded-xl shadow-lg flex flex-col">
                        <h3 class="text-2xl font-bold mb-3">호가창</h3>
                        <div id="orderbook-summary" class="bg-gray-700 p-3 rounded-lg mb-3 text-center">
                            <div class="flex justify-between items-center text-base font-semibold mb-2">
                                <span id="total-ask-volume" class="text-blue-400">총 매도: 0.00</span>
                                <span id="current-price-summary" class="text-2xl text-white font-bold">--</span>
                                <span id="total-bid-volume" class="text-red-400">총 매수: 0.00</span>
                            </div>
                            <div class="w-full h-3 bg-gray-500 rounded-full overflow-hidden">
                                <div id="orderbook-strength-bar" class="h-full" style="width: 50%; background-color: #ef4444;"></div>
                            </div>
                            <div class="flex justify-between text-sm text-gray-400 mt-2">
                                <span>매수 우세</span>
                                <span>매도 우세</span>
                            </div>
                        </div>
                        <div id="orderbook" class="scroll-container overflow-y-auto flex-grow">
                            <div class="flex justify-center items-center h-full">
                                <div class="text-gray-500">호가 데이터를 불러오는 중...</div>
                            </div>
                        </div>
                    </div>
                    <div id="trade-history-panel" class="bg-gray-800 p-6 rounded-xl shadow-lg flex flex-col">
                        <h3 class="text-2xl font-bold mb-3">체결 내역</h3>
                        <div id="trade-history" class="scroll-container overflow-y-auto flex-grow">
                            <div class="flex justify-center items-center h-full">
                                <div class="text-gray-500">체결 내역을 불러오는 중...</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="coin-list-container" class="lg:col-span-1 bg-gray-800 p-6 rounded-xl shadow-lg flex flex-col">
                <div class="grid grid-cols-2 mb-6 rounded-lg overflow-hidden border border-gray-700 bg-gray-700">
                    <button id="upbit-tab" class="tab-button py-3 text-gray-400 text-base font-semibold transition-colors duration-200 hover:bg-gray-600">원화 마켓</button>
                    <button id="binance-tab" class="tab-button py-3 text-gray-400 text-base font-semibold transition-colors duration-200 hover:bg-gray-600 active">USDT 마켓</button>
                </div>
                <div id="coin-list-headers" class="grid grid-cols-6 text-sm text-gray-400 font-semibold mb-3 px-4">
                    <span id="sort-korean-name" class="col-span-1 cursor-pointer hover:text-gray-200 text-left">코인명</span>
                    <span id="sort-trade-price" class="col-span-1 cursor-pointer hover:text-gray-200 text-right">현재가</span>
                    <span id="sort-signed-change-rate" class="col-span-1 cursor-pointer hover:text-gray-200 text-right">변동률(%)</span>
                    <span class="col-span-3 text-right flex justify-between">
                         <span class="chart-header">1일</span>
                         <span class="chart-header">7일</span>
                         <span class="chart-header">30일</span>
                    </span>
                </div>
                <div id="coin-list" class="scroll-container overflow-y-auto h-[90vh]">
                    <div class="flex justify-center items-center h-full">
                        <div class="text-gray-500">코인 목록을 불러오는 중...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>
    <script type="text/javascript">
        let tvWidget;
        let ws;
        let currentTab = 'binance';
        let currentMarket = 'binance';
        let currentCoin = 'BTCUSDT';
        let currentKoreanName = '비트코인';
        let recentTrades = [];
        let coins = [];
        let sortOrder = { key: 'trade_volume_24h', direction: 'desc' };
        
        // 캐시 데이터 저장 객체 추가
        let cache = {
            upbitCoins: null,
            binanceCoins: null
        };

        let binanceOrderbookData = {
            bids: [],
            asks: [],
            lastUpdateId: -1,
        };
        let isBinanceOrderbookReady = false;

        const upbitTabEl = document.getElementById('upbit-tab');
        const binanceTabEl = document.getElementById('binance-tab');
        const coinTickerEl = document.getElementById('coin-ticker');
        const coinKoreanNameEl = document.getElementById('coin-korean-name');
        const currentPriceEl = document.getElementById('current-price');
        const tradeVolumeEl = document.getElementById('trade-volume');
        const executionStrengthEl = document.getElementById('execution-strength');
        const orderbookEl = document.getElementById('orderbook');
        const tradeHistoryEl = document.getElementById('trade-history');
        const coinListEl = document.getElementById('coin-list');
        const tradingviewChartContainer = document.getElementById('tradingview_chart');
        const marketStatsEl = document.getElementById('market-stats');
        const orderbookSummaryEl = document.getElementById('orderbook-summary');
        const currentPriceSummaryEl = document.getElementById('current-price-summary');
        const totalAskVolumeEl = document.getElementById('total-ask-volume');
        const totalBidVolumeEl = document.getElementById('total-bid-volume');
        const orderbookStrengthBarEl = document.getElementById('orderbook-strength-bar');

        upbitTabEl.addEventListener('click', () => switchTab('upbit'));
        binanceTabEl.addEventListener('click', () => switchTab('binance'));

        document.getElementById('sort-korean-name').addEventListener('click', () => sortCoins('korean_name'));
        document.getElementById('sort-trade-price').addEventListener('click', () => sortCoins('trade_price'));
        document.getElementById('sort-signed-change-rate').addEventListener('click', () => sortCoins('signed_change_rate'));

        window.onload = async function () {
            await fetchUpbitCoinList();
            await fetchBinanceCoinList();
            switchTab('binance');
        };

        function switchTab(tab) {
            currentTab = tab;
            upbitTabEl.classList.remove('active');
            binanceTabEl.classList.remove('active');

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }

            // 캐시 데이터가 있는지 확인하여 즉시 렌더링
            if (tab === 'upbit' && cache.upbitCoins) {
                upbitTabEl.classList.add('active');
                currentMarket = 'upbit';
                coins = cache.upbitCoins;
                currentCoin = coins[0].market;
                currentKoreanName = coins[0].korean_name;
                renderCoinList();
                initWebSocket(currentMarket, currentCoin);
                initTradingView(currentMarket, currentCoin);
            } else if (tab === 'binance' && cache.binanceCoins) {
                binanceTabEl.classList.add('active');
                currentMarket = 'binance';
                coins = cache.binanceCoins;
                currentCoin = coins[0].market;
                currentKoreanName = coins[0].korean_name;
                renderCoinList();
                initWebSocket(currentMarket, currentCoin);
                initTradingView(currentMarket, currentCoin);
            }
        }

        async function fetchUpbitCoinList() {
            // 캐시 데이터가 있으면 반환
            if (cache.upbitCoins) {
                upbitCoins = cache.upbitCoins;
                return;
            }
            try {
                const response = await fetch('https://api.upbit.com/v1/market/all?isDetails=true');
                const allMarkets = await response.json();
                
                let upbitCoinsData = allMarkets
                    .filter(market => market.market.startsWith('KRW-'))
                    .map(market => ({
                        market: market.market,
                        korean_name: market.korean_name,
                        english_name: market.english_name,
                        trade_price: 0,
                        trade_volume_24h: 0,
                        signed_change_rate: 0,
                        sparklineData: {}
                    }));
                
                await fetchUpbitTickers(upbitCoinsData);
                await fetchUpbitSparklineData(upbitCoinsData);

                upbitCoins = upbitCoinsData;
                cache.upbitCoins = upbitCoinsData; // 캐시에 저장
            } catch (error) {
                console.error('Error fetching Upbit coin list:', error);
            }
        }

        async function fetchUpbitTickers(coinsList) {
            try {
                const markets = coinsList.map(c => c.market).join(',');
                const response = await fetch(`https://api.upbit.com/v1/ticker?markets=${markets}`);
                const tickers = await response.json();
                
                tickers.forEach(ticker => {
                    const coin = coinsList.find(c => c.market === ticker.market);
                    if (coin) {
                        coin.trade_price = ticker.trade_price;
                        coin.trade_volume_24h = ticker.acc_trade_price_24h;
                        coin.signed_change_rate = ticker.signed_change_rate;
                    }
                });
            } catch (error) {
                console.error('Error fetching Upbit tickers:', error);
            }
        }

        async function fetchUpbitSparklineData(coinsList) {
            const periods = { '1d': '1h', '7d': '4h', '30d': '1d' };
            const promises = coinsList.map(async (coin) => {
                coin.sparklineData = {};
                for (const period in periods) {
                    const interval = periods[period];
                    let limit = 0;
                    if (period === '1d') limit = 24;
                    else if (period === '7d') limit = 42;
                    else if (period === '30d') limit = 30;

                    try {
                        const response = await fetch(`https://api.upbit.com/v1/candles/${interval}?market=${coin.market}&count=${limit}`);
                        const klines = await response.json();
                        coin.sparklineData[period] = klines.map(kline => kline.trade_price).reverse();
                    } catch (error) {
                        console.error(`Error fetching klines for ${coin.market} (${period}):`, error);
                    }
                }
            });
            await Promise.all(promises);
        }

        async function fetchBinanceCoinList() {
            // 캐시 데이터가 있으면 반환
            if (cache.binanceCoins) {
                binanceCoins = cache.binanceCoins;
                return;
            }
            try {
                const response = await fetch('https://api.binance.com/api/v3/exchangeInfo');
                const exchangeInfo = await response.json();
                
                let binanceCoinsData = exchangeInfo.symbols
                    .filter(symbol => symbol.quoteAsset === 'USDT' && symbol.status === 'TRADING')
                    .map(symbol => ({
                        market: symbol.symbol,
                        korean_name: symbol.baseAsset,
                        trade_price: 0,
                        trade_volume_24h: 0,
                        signed_change_rate: 0,
                        sparklineData: {}
                    }));
                
                await fetchBinanceTickers(binanceCoinsData);
                await fetchBinanceSparklineData(binanceCoinsData);

                binanceCoins = binanceCoinsData;
                cache.binanceCoins = binanceCoinsData; // 캐시에 저장
            } catch (error) {
                console.error('Error fetching Binance coin list:', error);
            }
        }
        
        async function fetchBinanceTickers(coinsList) {
            try {
                const response = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbols=${JSON.stringify(coinsList.map(c => c.market))}`);
                const tickers = await response.json();
                
                tickers.forEach(ticker => {
                    const coin = coinsList.find(c => c.market === ticker.symbol);
                    if (coin) {
                        coin.trade_price = parseFloat(ticker.lastPrice);
                        coin.trade_volume_24h = parseFloat(ticker.quoteVolume);
                        coin.signed_change_rate = parseFloat(ticker.priceChangePercent);
                    }
                });
            } catch (error) {
                console.error('Error fetching Binance tickers:', error);
            }
        }
        
        async function fetchBinanceSparklineData(coinsList) {
            const periods = {
                '1d': { interval: '1h', limit: 24 },
                '7d': { interval: '4h', limit: 42 },
                '30d': { interval: '1d', limit: 30 }
            };
            const promises = coinsList.map(async (coin) => {
                coin.sparklineData = {};
                for (const period in periods) {
                    const { interval, limit } = periods[period];
                    try {
                        const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${coin.market}&interval=${interval}&limit=${limit}`);
                        const klines = await response.json();
                        coin.sparklineData[period] = klines.map(kline => parseFloat(kline[4]));
                    } catch (error) {
                        console.error(`Error fetching klines for ${coin.market} (${period}):`, error);
                    }
                }
            });
            await Promise.all(promises);
        }

        function sortCoins(key) {
            if (sortOrder.key === key) {
                sortOrder.direction = sortOrder.direction === 'asc' ? 'desc' : 'asc';
            } else {
                sortOrder.key = key;
                sortOrder.direction = 'asc';
            }
            
            coins.sort((a, b) => {
                let valA, valB;
                
                if (key === 'korean_name') {
                    valA = a.korean_name;
                    valB = b.korean_name;
                } else {
                    valA = key === 'trade_price' ? a.trade_price : a.signed_change_rate;
                    valB = key === 'trade_price' ? b.trade_price : b.signed_change_rate;
                }
                
                if (typeof valA === 'string') {
                    return sortOrder.direction === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                } else {
                    return sortOrder.direction === 'asc' ? valA - valB : valB - valA;
                }
            });
            renderCoinList();
        }

        function renderCoinList() {
            coinListEl.innerHTML = '';
            
            coins.forEach(coin => {
                const changeRate = coin.signed_change_rate || 0;
                const changeRateColor = changeRate > 0 ? 'text-green-400' : (changeRate < 0 ? 'text-red-400' : 'text-gray-300');
                
                const item = document.createElement('div');
                item.className = 'coin-list-item grid grid-cols-6 p-4 border-b border-gray-700 items-center';
                
                item.innerHTML = `
                    <div class="col-span-1 text-gray-300 font-semibold text-left text-base">${coin.korean_name}</div>
                    <div class="col-span-1 text-base text-gray-300 text-right">${(coin.trade_price || 0).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 4 })}</div>
                    <div class="col-span-1 text-base text-right ${changeRateColor} font-semibold">${(changeRate || 0).toFixed(2)}%</div>
                    <div class="col-span-3 flex justify-between items-center">
                        <div class="sparkline-container"><canvas class="sparkline-canvas" data-period="1d" data-sparkline="${coin.market}"></canvas></div>
                        <div class="sparkline-container"><canvas class="sparkline-canvas" data-period="7d" data-sparkline="${coin.market}"></canvas></div>
                        <div class="sparkline-container"><canvas class="sparkline-canvas" data-period="30d" data-sparkline="${coin.market}"></canvas></div>
                    </div>
                `;
                item.addEventListener('click', () => {
                    switchCoin(coin.market, coin.korean_name);
                });
                coinListEl.appendChild(item);

                requestAnimationFrame(() => {
                    if (coin.sparklineData) {
                        drawSparkline(item.querySelector('[data-period="1d"]'), coin.sparklineData['1d']);
                        drawSparkline(item.querySelector('[data-period="7d"]'), coin.sparklineData['7d']);
                        drawSparkline(item.querySelector('[data-period="30d"]'), coin.sparklineData['30d']);
                    }
                });
            });
        }
        
        function drawSparkline(canvas, data) {
            const ctx = canvas.getContext('2d');
            const parentWidth = canvas.parentElement.offsetWidth;
            const parentHeight = canvas.parentElement.offsetHeight;
            canvas.width = parentWidth;
            canvas.height = parentHeight;

            if (!data || data.length < 2) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }

            const min = Math.min(...data);
            const max = Math.max(...data);
            const range = max - min;
            const stepX = canvas.width / (data.length - 1);
            
            const startPrice = data[0];
            const endPrice = data[data.length - 1];
            const lineColor = endPrice >= startPrice ? '#10b981' : '#ef4444';

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - ((data[0] - min) / range) * canvas.height);

            for (let i = 1; i < data.length; i++) {
                const x = i * stepX;
                const y = canvas.height - ((data[i] - min) / range) * canvas.height;
                ctx.lineTo(x, y);
            }

            ctx.strokeStyle = lineColor;
            ctx.lineWidth = 1.5;
            ctx.stroke();
        }

        function switchCoin(market, koreanName) {
            if (currentCoin === market) return;

            currentCoin = market;
            currentKoreanName = koreanName;
            
            coinTickerEl.textContent = market;
            coinKoreanNameEl.textContent = koreanName;
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }

            if (currentMarket === 'binance') {
                binanceOrderbookData.bids = [];
                binanceOrderbookData.asks = [];
                binanceOrderbookData.lastUpdateId = -1;
                isBinanceOrderbookReady = false;
            } else {
                orderbookEl.innerHTML = `<div class="flex justify-center items-center h-full"><div class="text-gray-500">호가 데이터를 불러오는 중...</div></div>`;
                tradeHistoryEl.innerHTML = `<div class="flex justify-center items-center h-full"><div class="text-gray-500">체결 내역을 불러오는 중...</div></div>`;
            }
            
            initWebSocket(currentMarket, currentCoin);
            if (tvWidget) {
                tradingviewChartContainer.innerHTML = '';
            }
            initTradingView(currentMarket, currentCoin);
        }

        function initTradingView(market, coin) {
            let tradingViewSymbol;
            if (market === 'upbit') {
                const [currency, ticker] = coin.split('-');
                tradingViewSymbol = `UPBIT:${ticker}${currency}`;
            } else {
                tradingViewSymbol = `BINANCE:${coin}`;
            }

            tvWidget = new TradingView.widget(
                {
                    "autosize": true,
                    "symbol": tradingViewSymbol,
                    "interval": "60",
                    "timezone": "Etc/UTC",
                    "theme": "dark",
                    "style": "1",
                    "locale": "kr",
                    "toolbar_bg": "#f1f3f6",
                    "enable_publishing": false,
                    "hide_side_toolbar": true,
                    "allow_symbol_change": true,
                    "container_id": "tradingview_chart"
                }
            );
        }
        
        function initWebSocket(market, coin) {
            if (market === 'upbit') {
                initUpbitWebSocket(coin);
            } else if (market === 'binance') {
                initBinanceWebSocket(coin);
            }
        }

        function initUpbitWebSocket(market) {
            const wsUrl = `wss://api.upbit.com/websocket/v1`;
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log(`Upbit WebSocket 연결 성공: ${market}`);
                const message = [
                    { ticket: "test" },
                    { type: "trade", codes: coins.map(c => c.market) },
                    { type: "orderbook", codes: coins.map(c => c.market)}
                ];
                ws.send(JSON.stringify(message));
            };

            ws.onmessage = (event) => {
                const fileReader = new FileReader();
                fileReader.onload = () => {
                    const data = JSON.parse(fileReader.result);
                    
                    if (data.type === 'orderbook') {
                        if (data.code === currentCoin) {
                            updateUpbitOrderbookUI(data.orderbook_units);
                        }
                    } else if (data.type === 'trade') {
                        const updatedCoinIndex = coins.findIndex(c => c.market === data.code);
                        if (updatedCoinIndex !== -1) {
                            coins[updatedCoinIndex].trade_price = data.trade_price;
                            const openPrice = coins[updatedCoinIndex].trade_price / (1 + coins[updatedCoinIndex].signed_change_rate);
                            const newChangeRate = ((data.trade_price - openPrice) / openPrice) * 100;
                            coins[updatedCoinIndex].signed_change_rate = data.signed_change_rate;

                            if (currentMarket === 'upbit') {
                                renderCoinList();
                            }
                        }
                        
                        if (data.code === currentCoin) {
                            updateUpbitTradeHistory(data);
                            currentPriceEl.textContent = data.trade_price.toLocaleString('ko-KR');
                        }
                    }
                };
                fileReader.readAsText(event.data);
            };
            
            ws.onclose = () => {
                console.log(`Upbit WebSocket 연결 종료: ${market}`);
            };
            
            ws.onerror = (error) => {
                console.error(`Upbit WebSocket 오류 발생: ${market}`, error);
            };
        }

        function updateUpbitOrderbookUI(orderbookUnits) {
            orderbookEl.innerHTML = '';
            
            let maxAskSize = 0;
            let maxBidSize = 0;
            orderbookUnits.forEach(unit => {
                if (unit.ask_size > maxAskSize) maxAskSize = unit.ask_size;
                if (unit.bid_size > maxBidSize) maxBidSize = unit.bid_size;
            });
            const maxVolume = Math.max(maxAskSize, maxBidSize);

            const table = document.createElement('table');
            table.className = 'w-full text-base';
            
            const askHtml = orderbookUnits.map(unit => `
                <tr class="orderbook-row h-12">
                    <td class="relative w-1/3 text-right pr-3">
                        <div class="orderbook-background bg-blue-900 ask-bg" style="width: ${(unit.ask_size / maxVolume) * 100}%"></div>
                        <span class="relative z-10 text-gray-300">${unit.ask_size.toFixed(4)}</span>
                    </td>
                    <td class="text-blue-400 font-bold text-center w-1/3 text-lg">${unit.ask_price.toLocaleString('ko-KR')}</td>
                    <td class="w-1/3"></td>
                </tr>
            `).reverse().join('');

            const bidHtml = orderbookUnits.map(unit => `
                <tr class="orderbook-row h-12">
                    <td class="w-1/3"></td>
                    <td class="text-red-400 font-bold text-center w-1/3 text-lg">${unit.bid_price.toLocaleString('ko-KR')}</td>
                    <td class="relative w-1/3 text-left pl-3">
                        <div class="orderbook-background bg-red-900 bid-bg" style="width: ${(unit.bid_size / maxVolume) * 100}%"></div>
                        <span class="relative z-10 text-gray-300">${unit.bid_size.toFixed(4)}</span>
                    </td>
                </tr>
            `).join('');

            const totalAskSize = orderbookUnits.reduce((acc, unit) => acc + unit.ask_size, 0);
            const totalBidSize = orderbookUnits.reduce((acc, unit) => acc + unit.bid_size, 0);

            const askVolumeClass = totalAskSize > totalBidSize ? 'font-bold text-xl' : 'font-semibold';
            const bidVolumeClass = totalBidSize > totalAskSize ? 'font-bold text-xl' : 'font-semibold';

            table.innerHTML = `
                <thead class="text-gray-400 font-bold">
                    <tr><th colspan="3" class="py-2 text-xl">매도 호가</th></tr>
                    <tr class="text-sm">
                        <th class="w-1/3 text-right">수량</th>
                        <th class="w-1/3 text-center">가격</th>
                        <th class="w-1/3"></th>
                    </tr>
                </thead>
                <tbody>${askHtml}</tbody>
                <tbody class="bg-gray-700 text-gray-300 font-bold text-center text-2xl">
                    <tr><td colspan="3" class="py-3">현재가: <span id="current-price-orderbook">${orderbookUnits[0].ask_price.toLocaleString('ko-KR')}</span></td></tr>
                </tbody>
                <thead class="text-gray-400 font-bold">
                    <tr><th colspan="3" class="py-2 text-xl">매수 호가</th></tr>
                    <tr class="text-sm">
                        <th class="w-1/3"></th>
                        <th class="w-1/3 text-center">가격</th>
                        <th class="w-1/3 text-left">수량</th>
                    </tr>
                </thead>
                <tbody>${bidHtml}</tbody>
                <tfoot class="bg-gray-700 text-gray-300">
                    <tr><td colspan="3" class="py-2 text-center text-lg">
                        <span class="text-blue-400 ${askVolumeClass}">총 매도물량: ${totalAskSize.toFixed(4)}</span> | 
                        <span class="text-red-400 ${bidVolumeClass}">총 매수물량: ${totalBidSize.toFixed(4)}</span>
                    </td></tr>
                </tfoot>
            `;
            orderbookEl.appendChild(table);
        }
        
        function updateUpbitTradeHistory(data) {
            recentTrades.unshift({ 
                price: data.trade_price, 
                volume: data.trade_volume, 
                ask_bid: data.ask_bid, 
                timestamp: data.trade_timestamp 
            });

            if (recentTrades.length > 50) {
                recentTrades.splice(50);
            }

            tradeHistoryEl.innerHTML = '';
            let totalBuyVolume = 0;
            let totalSellVolume = 0;
            
            const historyTable = document.createElement('table');
            historyTable.className = 'w-full text-base';
            
            const historyHtml = recentTrades.map(trade => {
                const isBuy = trade.ask_bid === 'BID';
                const color = isBuy ? 'text-red-400' : 'text-blue-400';
                const tradeTime = new Date(trade.timestamp).toLocaleTimeString('ko-KR');

                if (isBuy) totalBuyVolume += trade.volume;
                else totalSellVolume += trade.volume;

                return `
                    <tr>
                        <td class="py-1 text-left ${color} font-bold w-1/3">${tradeTime}</td>
                        <td class="py-1 text-right ${color} font-bold w-1/3">${trade.price.toLocaleString('ko-KR')}</td>
                        <td class="py-1 text-right ${color} w-1/3">${trade.volume.toFixed(4)}</td>
                    </tr>
                `;
            }).join('');

            historyTable.innerHTML = `
                <thead class="bg-gray-700 text-gray-300">
                    <tr>
                        <th class="py-1 text-left w-1/3 text-sm">시간</th>
                        <th class="py-1 text-right w-1/3 text-sm">가격</th>
                        <th class="py-1 text-right w-1/3 text-sm">수량</th>
                    </tr>
                </thead>
                <tbody>${historyHtml}</tbody>
            `;
            tradeHistoryEl.appendChild(historyTable);

            const totalVolume = totalBuyVolume + totalSellVolume;
            if (totalVolume > 0) {
                const strength = (totalBuyVolume / totalVolume) * 100;
                executionStrengthEl.textContent = `${strength.toFixed(2)}`;
            } else {
                executionStrengthEl.textContent = `0.00`;
            }

            currentPriceEl.textContent = data.trade_price.toLocaleString('ko-KR');
        }

        async function fetchBinanceOrderbookSnapshot(market) {
            try {
                const response = await fetch(`https://api.binance.com/api/v3/depth?symbol=${market.toUpperCase()}&limit=1000`);
                const data = await response.json();
                
                binanceOrderbookData.bids = data.bids;
                binanceOrderbookData.asks = data.asks;
                binanceOrderbookData.lastUpdateId = data.lastUpdateId;
                isBinanceOrderbookReady = true;

                updateBinanceOrderbookUI();
            } catch (error) {
                console.error('Error fetching Binance orderbook snapshot:', error);
            }
        }

        function mergeBinanceOrderbook(updates) {
            updates.forEach(update => {
                const price = update[0];
                const quantity = parseFloat(update[1]);
                
                if (quantity === 0) {
                    binanceOrderbookData.bids = binanceOrderbookData.bids.filter(item => item[0] !== price);
                    binanceOrderbookData.asks = binanceOrderbookData.asks.filter(item => item[0] !== price);
                } else {
                    const existingBid = binanceOrderbookData.bids.find(item => item[0] === price);
                    const existingAsk = binanceOrderbookData.asks.find(item => item[0] === price);

                    if (existingBid) {
                        existingBid[1] = quantity.toString();
                    } else if (existingAsk) {
                        existingAsk[1] = quantity.toString();
                    } else {
                        const newEntry = [price, quantity.toString()];
                        if (parseFloat(price) > parseFloat(binanceOrderbookData.bids[0][0])) {
                            binanceOrderbookData.asks.push(newEntry);
                        } else {
                            binanceOrderbookData.bids.push(newEntry);
                        }
                    }
                }
            });

            binanceOrderbookData.bids.sort((a, b) => parseFloat(b[0]) - parseFloat(a[0]));
            binanceOrderbookData.asks.sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]));
        }

        function initBinanceWebSocket(market) {
            fetchBinanceOrderbookSnapshot(market);
            
            const wsUrl = `wss://stream.binance.com:9443/ws/${market.toLowerCase()}@trade/${market.toLowerCase()}@depth`;
            ws = new WebSocket(wsUrl);
            recentTrades = [];

            ws.onopen = () => {
                console.log(`Binance WebSocket 연결 성공: ${market}`);
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);

                if (data.e === 'trade') {
                    const updatedCoinIndex = coins.findIndex(c => c.market.toLowerCase() === data.s.toLowerCase());
                    if (updatedCoinIndex !== -1) {
                        coins[updatedCoinIndex].trade_price = parseFloat(data.p);
                        if (currentMarket === 'binance') {
                            renderCoinList();
                        }
                    }
                    updateBinanceTradeHistory(parseFloat(data.p), parseFloat(data.q), data.m);
                    currentPriceEl.textContent = parseFloat(data.p).toLocaleString('en-US');
                } else if (data.e === 'depthUpdate') {
                    if (!isBinanceOrderbookReady) {
                        return;
                    }
                    
                    mergeBinanceOrderbook(data.a);
                    mergeBinanceOrderbook(data.b);
                    updateBinanceOrderbookUI();
                }
            };

            ws.onclose = () => {
                console.log(`Binance WebSocket 연결 종료: ${market}`);
            };

            ws.onerror = (error) => {
                console.error(`Binance WebSocket 오류 발생: ${market}`, error);
            };
        }
        
        function updateBinanceOrderbookUI() {
            orderbookEl.innerHTML = '';

            const fixedAsks = binanceOrderbookData.asks.slice(0, 30);
            const fixedBids = binanceOrderbookData.bids.slice(0, 30);

            let maxAskSize = 0;
            let maxBidSize = 0;
            fixedAsks.forEach(ask => { if (parseFloat(ask[1]) > maxAskSize) maxAskSize = parseFloat(ask[1]); });
            fixedBids.forEach(bid => { if (parseFloat(bid[1]) > maxBidSize) maxBidSize = parseFloat(bid[1]); });
            const maxVolume = Math.max(maxAskSize, maxBidSize);

            const totalAskSize = fixedAsks.reduce((acc, ask) => acc + parseFloat(ask[1]), 0);
            const totalBidSize = fixedBids.reduce((acc, bid) => acc + parseFloat(bid[1]), 0);

            const totalOrderbookVolume = totalAskSize + totalBidSize;
            let bidStrength = 0;
            if (totalOrderbookVolume > 0) {
                bidStrength = (totalBidSize / totalOrderbookVolume) * 100;
            }
            const strengthColor = bidStrength >= 50 ? '#ef4444' : '#10b981';

            currentPriceSummaryEl.textContent = fixedAsks.length > 0 ? parseFloat(fixedAsks[0][0]).toLocaleString('en-US') : '--';
            totalAskVolumeEl.textContent = `총 매도: ${totalAskSize.toFixed(2)}`;
            totalBidVolumeEl.textContent = `총 매수: ${totalBidSize.toFixed(2)}`;
            orderbookStrengthBarEl.style.width = `${bidStrength}%`;
            orderbookStrengthBarEl.style.backgroundColor = strengthColor;

            const table = document.createElement('table');
            table.className = 'w-full text-base';
            
            const askHtml = fixedAsks.reverse().map(ask => `
                <tr class="orderbook-row h-12">
                    <td class="relative w-1/3 text-right pr-3">
                        <div class="orderbook-background bg-blue-900 ask-bg" style="width: ${(parseFloat(ask[1]) / maxVolume) * 100}%"></div>
                        <span class="relative z-10 text-gray-300">${parseFloat(ask[1]).toFixed(4)}</span>
                    </td>
                    <td class="text-blue-400 font-bold text-center w-1/3 text-lg">${parseFloat(ask[0]).toLocaleString('en-US')}</td>
                    <td class="w-1/3"></td>
                </tr>
            `).join('');

            const bidHtml = fixedBids.map(bid => `
                <tr class="orderbook-row h-12">
                    <td class="w-1/3"></td>
                    <td class="text-red-400 font-bold text-center w-1/3 text-lg">${parseFloat(bid[0]).toLocaleString('en-US')}</td>
                    <td class="relative w-1/3 text-left pl-3">
                        <div class="orderbook-background bg-red-900 bid-bg" style="width: ${(parseFloat(bid[1]) / maxVolume) * 100}%"></div>
                        <span class="relative z-10 text-gray-300">${parseFloat(bid[1]).toFixed(4)}</span>
                    </td>
                </tr>
            `).join('');

            table.innerHTML = `
                <thead class="text-gray-400 font-bold">
                    <tr><th colspan="3" class="py-2 text-xl">매도 호가</th></tr>
                    <tr class="text-sm">
                        <th class="w-1/3 text-right">수량</th>
                        <th class="w-1/3 text-center">가격</th>
                        <th class="w-1/3"></th>
                    </tr>
                </thead>
                <tbody>${askHtml}</tbody>
                <thead class="text-gray-400 font-bold">
                    <tr><th colspan="3" class="py-2 text-xl">매수 호가</th></tr>
                    <tr class="text-sm">
                        <th class="w-1/3"></th>
                        <th class="w-1/3 text-center">가격</th>
                        <th class="w-1/3 text-left">수량</th>
                    </tr>
                </thead>
                <tbody>${bidHtml}</tbody>
            `;
            orderbookEl.appendChild(table);
        }

        function updateBinanceTradeHistory(price, volume, isBuyerMaker) {
            const ask_bid = isBuyerMaker ? 'ASK' : 'BID';
            const timestamp = Date.now();
            
            recentTrades.unshift({ price, volume, ask_bid, timestamp });

            if (recentTrades.length > 50) {
                recentTrades.splice(50);
            }

            tradeHistoryEl.innerHTML = '';
            let totalBuyVolume = 0;
            let totalSellVolume = 0;
            
            const historyTable = document.createElement('table');
            historyTable.className = 'w-full text-base';
            
            const historyHtml = recentTrades.map(trade => {
                const isBuy = trade.ask_bid === 'BID';
                const color = isBuy ? 'text-red-400' : 'text-blue-400';
                const tradeTime = new Date(trade.timestamp).toLocaleTimeString('ko-KR');

                if (isBuy) totalBuyVolume += trade.volume;
                else totalSellVolume += trade.volume;

                return `
                    <tr>
                        <td class="py-1 text-left ${color} font-bold w-1/3">${tradeTime}</td>
                        <td class="py-1 text-right ${color} font-bold w-1/3">${trade.price.toLocaleString('en-US')}</td>
                        <td class="py-1 text-right ${color} w-1/3">${trade.volume.toFixed(4)}</td>
                    </tr>
                `;
            }).join('');

            historyTable.innerHTML = `
                <thead class="bg-gray-700 text-gray-300">
                    <tr>
                        <th class="py-1 text-left w-1/3 text-sm">시간</th>
                        <th class="py-1 text-right w-1/3 text-sm">가격</th>
                        <th class="py-1 text-right w-1/3 text-sm">수량</th>
                    </tr>
                </thead>
                <tbody>${historyHtml}</tbody>
            `;
            tradeHistoryEl.appendChild(historyTable);

            const totalVolume = totalBuyVolume + totalSellVolume;
            if (totalVolume > 0) {
                const strength = (totalBuyVolume / totalVolume) * 100;
                executionStrengthEl.textContent = `${strength.toFixed(2)}`;
            } else {
                executionStrengthEl.textContent = `0.00`;
            }
        }
    </script>
</body>
</html>